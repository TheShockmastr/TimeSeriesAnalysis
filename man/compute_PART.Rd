% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/PART.R
\name{compute_PART}
\alias{compute_PART}
\title{compute PART clusters}
\usage{
compute_PART(
  object,
  part_recursion = 100,
  part_min_clust = 10,
  dist_param = "euclidean",
  hclust_param = "average",
  custom_seed = NULL,
  custom_matrix = NULL,
  return_as_object = TRUE,
  vignette_run = FALSE
)
}
\arguments{
\item{object}{A timeseries object}

\item{part_recursion}{The number of recursions for PART calculation}

\item{part_min_clust}{The minimum number of genes per cluster}

\item{dist_param}{The distance parameter for clustering}

\item{hclust_param}{The hierarchical clustering method/parameter to be used}

\item{custom_seed}{The seed inputed (if any)}

\item{custom_matrix}{Allows the input of a custom matrix instead of taking it
from the object}

\item{return_as_object}{Boolean indicating if the results should be returned
within the submitted object or as a list}

\item{vignette_run}{Boolean indicating if this is for Vignettes, if so the function
will load the appropriate example data instead of performing the computation.}
}
\value{
The timeseries object with the PART results added
}
\description{
The function set's a seed for reproducibility of results, it then uses the
part function from the clusterGenomics package to establish which genes belong
to what clusters. The clusters are then ordered using hierarchical clustering.
This may result in some PART cluster being split, therefore the order is adjusted
to put them together. We first order using hierarchical clustering for visual purposes.
}
\examples{
TS_object<-create_example_object_for_R()
TS_object <- normalize_timeSeries_with_deseq2(time_object=TS_object)
#Perform conditional differential gene expression analysis
TS_object<-conditional_DE_wrapper(TS_object,vignette_run=TRUE)
TS_object<-temporal_DE_wrapper(TS_object,do_all_combinations=TRUE,vignette_run=TRUE)
#Extract genes for PART clustering based on defined log(2)foldChange threshold
signi_genes<-select_genes_with_l2fc(TS_object)

#Use all samples, but implement a custom order. In this case it is reversed
sample_data<-exp_sample_data(TS_object)
TS_groups<-slot(TS_object,'group_names')
samps_2<-sample_data$sample[sample_data$group==TS_groups[2]]
samps_1<-sample_data$sample[sample_data$group==TS_groups[1]]

#Create the matrix that will be used for PART clustering
TS_object<-prep_counts_for_PART(object=TS_object,target_genes=signi_genes,scale=TRUE,target_samples=c(samps_2,samps_1))
TS_object<-compute_PART(TS_object,part_recursion=10,part_min_clust=10,dist_param="euclidean", hclust_param="average",vignette_run=TRUE)

}
